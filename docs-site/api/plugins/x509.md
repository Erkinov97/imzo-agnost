# X509 Plugin API Reference

X509 plugin X.509 sertifikatlar bilan ishlash uchun mo'ljallangan. Bu plugin
sertifikatlarni o'qish, tekshirish, validatsiya qilish va ma'lumotlarni extract
qilish uchun ishlatiladi.

## Overview

X509 plugin quyidagi funksiyalarni taqdim etadi:

- X.509 sertifikat ma'lumotlarini o'qish
- Sertifikat validatsiyasi va tekshirish
- Certificate chain validation
- Sertifikat extension ma'lumotlari
- Certificate revocation checking
- Public key extraction

## Import

```typescript
// ES6 import
import { x509Plugin } from 'imzo-agnost';

// CommonJS
const { x509Plugin } = require('imzo-agnost');

// Global object (browser)
window.eimzoApi.x509;
```

## Types

```typescript
interface X509Certificate {
  version: number;
  serialNumber: string;
  issuer: string;
  subject: string;
  notBefore: string;
  notAfter: string;
  publicKey: string;
  signatureAlgorithm: string;
  fingerprint: string;
  extensions: X509Extension[];
}

interface X509Extension {
  oid: string;
  critical: boolean;
  value: string;
  name?: string;
}

interface CertificateValidation {
  valid: boolean;
  reason?: string;
  chainValid: boolean;
  revoked: boolean;
  expired: boolean;
  selfSigned: boolean;
}

interface CertificateInfo {
  success: boolean;
  certificate?: X509Certificate;
  reason?: string;
}

interface SubjectInfo {
  commonName: string;
  organization: string;
  organizationalUnit: string;
  country: string;
  state: string;
  locality: string;
  email?: string;
}

interface IssuerInfo {
  commonName: string;
  organization: string;
  country: string;
  email?: string;
}
```

## Certificate Reading

### parseCertificateAsync()

X.509 sertifikatni parse qilish va ma'lumotlarini olish.

**Basic Certificate Parsing:**

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...'; // Base64 certificate

  const result = await x509Plugin.parseCertificateAsync(certData);

  if (result.success && result.certificate) {
    const cert = result.certificate;

    console.log('Certificate Information:');
    console.log('Subject:', cert.subject);
    console.log('Issuer:', cert.issuer);
    console.log('Serial Number:', cert.serialNumber);
    console.log('Valid From:', cert.notBefore);
    console.log('Valid To:', cert.notAfter);
    console.log('Signature Algorithm:', cert.signatureAlgorithm);
    console.log('Fingerprint:', cert.fingerprint);
  }
} catch (error) {
  console.error('‚ùå Certificate parsing failed:', error);
}
```

**Detailed Certificate Analysis:**

```typescript
try {
  const certificateBase64 = getCertificateFromPFX(); // From PFX or other source

  const certInfo = await x509Plugin.parseCertificateAsync(certificateBase64);

  if (certInfo.success && certInfo.certificate) {
    const cert = certInfo.certificate;

    console.log('üìã Detailed Certificate Analysis:');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    // Basic info
    console.log('Version:', cert.version);
    console.log('Serial:', cert.serialNumber);

    // Validity period
    const notBefore = new Date(cert.notBefore);
    const notAfter = new Date(cert.notAfter);
    const now = new Date();

    console.log('Validity Period:');
    console.log(`  From: ${notBefore.toLocaleString()}`);
    console.log(`  To: ${notAfter.toLocaleString()}`);
    console.log(`  Current: ${now.toLocaleString()}`);
    console.log(
      `  Status: ${now >= notBefore && now <= notAfter ? '‚úÖ Valid' : '‚ùå Invalid'}`
    );

    // Subject and Issuer
    console.log('Subject:', cert.subject);
    console.log('Issuer:', cert.issuer);

    // Extensions
    console.log('Extensions:');
    cert.extensions.forEach((ext, index) => {
      console.log(
        `  ${index + 1}. ${ext.name || ext.oid} (Critical: ${ext.critical})`
      );
      console.log(
        `     Value: ${ext.value.substring(0, 50)}${ext.value.length > 50 ? '...' : ''}`
      );
    });

    // Public key info
    console.log(
      'Public Key (first 100 chars):',
      cert.publicKey.substring(0, 100) + '...'
    );
  }
} catch (error) {
  console.error('‚ùå Detailed certificate analysis failed:', error);
}
```

### getSubjectInfoAsync()

Sertifikat subject ma'lumotlarini structured formatda olish.

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const subjectInfo = await x509Plugin.getSubjectInfoAsync(certData);

  if (subjectInfo.success) {
    console.log('Subject Information:');
    console.log('Common Name (CN):', subjectInfo.commonName);
    console.log('Organization (O):', subjectInfo.organization);
    console.log('Organizational Unit (OU):', subjectInfo.organizationalUnit);
    console.log('Country (C):', subjectInfo.country);
    console.log('State/Province (ST):', subjectInfo.state);
    console.log('Locality (L):', subjectInfo.locality);
    console.log('Email:', subjectInfo.email || 'Not specified');
  }
} catch (error) {
  console.error('‚ùå Subject info extraction failed:', error);
}
```

### getIssuerInfoAsync()

Sertifikat issuer ma'lumotlarini olish.

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const issuerInfo = await x509Plugin.getIssuerInfoAsync(certData);

  if (issuerInfo.success) {
    console.log('Issuer Information:');
    console.log('CA Common Name:', issuerInfo.commonName);
    console.log('CA Organization:', issuerInfo.organization);
    console.log('CA Country:', issuerInfo.country);
    console.log('CA Email:', issuerInfo.email || 'Not specified');
  }
} catch (error) {
  console.error('‚ùå Issuer info extraction failed:', error);
}
```

### getPublicKeyAsync()

Sertifikatdan public key ni extract qilish.

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const publicKeyResult = await x509Plugin.getPublicKeyAsync(certData);

  if (publicKeyResult.success) {
    console.log('‚úÖ Public key extracted');
    console.log('Algorithm:', publicKeyResult.algorithm);
    console.log('Key Size:', publicKeyResult.keySize, 'bits');
    console.log('Public Key:', publicKeyResult.publicKey);

    // Public key ni boshqa operatsiyalar uchun ishlatish mumkin
    // Masalan, signature verification
  }
} catch (error) {
  console.error('‚ùå Public key extraction failed:', error);
}
```

## Certificate Validation

### validateCertificateAsync()

Sertifikat validatsiyasi va tekshirish.

**Basic Validation:**

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const validation = await x509Plugin.validateCertificateAsync(certData);

  console.log('Certificate Validation Results:');
  console.log('Overall Valid:', validation.valid ? '‚úÖ' : '‚ùå');
  console.log('Chain Valid:', validation.chainValid ? '‚úÖ' : '‚ùå');
  console.log('Not Revoked:', !validation.revoked ? '‚úÖ' : '‚ùå');
  console.log('Not Expired:', !validation.expired ? '‚úÖ' : '‚ùå');
  console.log('Self-Signed:', validation.selfSigned ? 'Yes' : 'No');

  if (!validation.valid) {
    console.log('Validation Failure Reason:', validation.reason);
  }
} catch (error) {
  console.error('‚ùå Certificate validation failed:', error);
}
```

**Advanced Validation with Options:**

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const validationOptions = {
    checkRevocation: true,
    checkChain: true,
    allowSelfSigned: false,
    truststoreId: 'default_truststore'
  };

  const validation = await x509Plugin.validateCertificateAsync(
    certData,
    validationOptions
  );

  console.log('Advanced Validation Results:');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

  if (validation.valid) {
    console.log('‚úÖ Certificate is valid and trusted');
  } else {
    console.log('‚ùå Certificate validation failed');
    console.log('Failure details:');

    if (validation.expired) {
      console.log('  - Certificate has expired');
    }
    if (validation.revoked) {
      console.log('  - Certificate has been revoked');
    }
    if (!validation.chainValid) {
      console.log('  - Certificate chain is invalid');
    }
    if (validation.reason) {
      console.log('  - Additional reason:', validation.reason);
    }
  }
} catch (error) {
  console.error('‚ùå Advanced validation failed:', error);
}
```

### validateCertificateChainAsync()

Certificate chain validatsiyasi.

```typescript
try {
  const certificateChain = [
    'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...', // End entity certificate
    'MIICBjCCAW+gAwIBAgIJAKS7Z9Z9Z9Z9...', // Intermediate CA
    'MIICBjCCAW+gAwIBAgIJAKS7Z9Z9Z9Z9...' // Root CA
  ];

  const chainValidation =
    await x509Plugin.validateCertificateChainAsync(certificateChain);

  if (chainValidation.valid) {
    console.log('‚úÖ Certificate chain is valid');
    console.log('Chain length:', certificateChain.length);
    console.log('Root CA trusted:', chainValidation.rootTrusted);
  } else {
    console.log('‚ùå Certificate chain validation failed');
    console.log('Broken at level:', chainValidation.brokenAtLevel);
    console.log('Reason:', chainValidation.reason);
  }
} catch (error) {
  console.error('‚ùå Chain validation failed:', error);
}
```

### checkRevocationAsync()

Sertifikat revocation status ni tekshirish.

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const revocationCheck = await x509Plugin.checkRevocationAsync(certData);

  if (revocationCheck.success) {
    console.log('Revocation Check Results:');
    console.log('Revoked:', revocationCheck.revoked ? '‚ùå Yes' : '‚úÖ No');

    if (revocationCheck.revoked) {
      console.log('Revocation Date:', revocationCheck.revocationDate);
      console.log('Revocation Reason:', revocationCheck.revocationReason);
    }

    console.log('Check Method:', revocationCheck.method); // CRL, OCSP, etc.
    console.log('Last Updated:', revocationCheck.lastUpdated);
  }
} catch (error) {
  console.error('‚ùå Revocation check failed:', error);
}
```

## Certificate Extensions

### getExtensionsAsync()

Sertifikat extensions ni o'qish va tahlil qilish.

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const extensions = await x509Plugin.getExtensionsAsync(certData);

  if (extensions.success) {
    console.log('Certificate Extensions:');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    extensions.list.forEach((ext, index) => {
      console.log(`\n${index + 1}. ${ext.name || 'Unknown Extension'}`);
      console.log(`   OID: ${ext.oid}`);
      console.log(`   Critical: ${ext.critical ? '‚ö†Ô∏è Yes' : 'No'}`);

      // Special handling for common extensions
      switch (ext.oid) {
        case '2.5.29.15': // Key Usage
          console.log(`   Key Usage: ${parseKeyUsage(ext.value)}`);
          break;
        case '2.5.29.37': // Extended Key Usage
          console.log(
            `   Extended Key Usage: ${parseExtendedKeyUsage(ext.value)}`
          );
          break;
        case '2.5.29.17': // Subject Alternative Name
          console.log(`   SAN: ${parseSubjectAltName(ext.value)}`);
          break;
        case '2.5.29.31': // CRL Distribution Points
          console.log(`   CRL Distribution: ${ext.value}`);
          break;
        default:
          console.log(
            `   Value: ${ext.value.substring(0, 100)}${ext.value.length > 100 ? '...' : ''}`
          );
      }
    });
  }
} catch (error) {
  console.error('‚ùå Extensions extraction failed:', error);
}

// Helper functions for extension parsing
function parseKeyUsage(value: string): string {
  // Parse key usage bits
  const usages = [];
  if (value.includes('digitalSignature')) usages.push('Digital Signature');
  if (value.includes('keyEncipherment')) usages.push('Key Encipherment');
  if (value.includes('dataEncipherment')) usages.push('Data Encipherment');
  return usages.join(', ') || 'Unknown';
}

function parseExtendedKeyUsage(value: string): string {
  // Parse extended key usage
  const usages = [];
  if (value.includes('1.3.6.1.5.5.7.3.1')) usages.push('Server Authentication');
  if (value.includes('1.3.6.1.5.5.7.3.2')) usages.push('Client Authentication');
  if (value.includes('1.3.6.1.5.5.7.3.3')) usages.push('Code Signing');
  if (value.includes('1.3.6.1.5.5.7.3.4')) usages.push('Email Protection');
  return usages.join(', ') || 'Unknown';
}

function parseSubjectAltName(value: string): string {
  // Parse Subject Alternative Name
  return value.replace(/,/g, ', ');
}
```

### getKeyUsageAsync()

Key Usage extension ni o'qish.

```typescript
try {
  const certData = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...';

  const keyUsage = await x509Plugin.getKeyUsageAsync(certData);

  if (keyUsage.success) {
    console.log('Key Usage Information:');
    console.log('Digital Signature:', keyUsage.digitalSignature ? '‚úÖ' : '‚ùå');
    console.log('Key Encipherment:', keyUsage.keyEncipherment ? '‚úÖ' : '‚ùå');
    console.log('Data Encipherment:', keyUsage.dataEncipherment ? '‚úÖ' : '‚ùå');
    console.log('Key Agreement:', keyUsage.keyAgreement ? '‚úÖ' : '‚ùå');
    console.log('Certificate Signing:', keyUsage.certSign ? '‚úÖ' : '‚ùå');
    console.log('CRL Signing:', keyUsage.crlSign ? '‚úÖ' : '‚ùå');
  }
} catch (error) {
  console.error('‚ùå Key usage extraction failed:', error);
}
```

## Complete Examples

### Certificate Analysis Workflow

```typescript
async function analyzeCertificate(certificateData: string) {
  try {
    console.log('üîç Starting comprehensive certificate analysis...');

    // 1. Parse basic certificate information
    console.log('1. Parsing certificate...');
    const certInfo = await x509Plugin.parseCertificateAsync(certificateData);

    if (!certInfo.success || !certInfo.certificate) {
      throw new Error('Failed to parse certificate');
    }

    const cert = certInfo.certificate;
    console.log('‚úÖ Certificate parsed successfully');

    // 2. Extract subject and issuer information
    console.log('2. Extracting subject/issuer info...');
    const [subjectInfo, issuerInfo] = await Promise.all([
      x509Plugin.getSubjectInfoAsync(certificateData),
      x509Plugin.getIssuerInfoAsync(certificateData)
    ]);

    // 3. Validate certificate
    console.log('3. Validating certificate...');
    const validation = await x509Plugin.validateCertificateAsync(
      certificateData,
      {
        checkRevocation: true,
        checkChain: true
      }
    );

    // 4. Check extensions
    console.log('4. Analyzing extensions...');
    const extensions = await x509Plugin.getExtensionsAsync(certificateData);
    const keyUsage = await x509Plugin.getKeyUsageAsync(certificateData);

    // 5. Extract public key
    console.log('5. Extracting public key...');
    const publicKey = await x509Plugin.getPublicKeyAsync(certificateData);

    // 6. Generate comprehensive report
    console.log('\nüìã CERTIFICATE ANALYSIS REPORT');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    // Basic Information
    console.log('\nüîπ BASIC INFORMATION:');
    console.log(`Version: ${cert.version}`);
    console.log(`Serial Number: ${cert.serialNumber}`);
    console.log(`Signature Algorithm: ${cert.signatureAlgorithm}`);
    console.log(`Fingerprint: ${cert.fingerprint}`);

    // Validity
    const now = new Date();
    const notBefore = new Date(cert.notBefore);
    const notAfter = new Date(cert.notAfter);
    const isCurrentlyValid = now >= notBefore && now <= notAfter;

    console.log('\nüîπ VALIDITY PERIOD:');
    console.log(`From: ${notBefore.toLocaleString()}`);
    console.log(`To: ${notAfter.toLocaleString()}`);
    console.log(
      `Status: ${isCurrentlyValid ? '‚úÖ Currently Valid' : '‚ùå Not Valid'}`
    );

    if (!isCurrentlyValid) {
      if (now < notBefore) {
        console.log(
          `‚ö†Ô∏è Certificate not yet valid (starts in ${Math.ceil((notBefore.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))} days)`
        );
      } else {
        console.log(
          `‚ö†Ô∏è Certificate expired ${Math.ceil((now.getTime() - notAfter.getTime()) / (1000 * 60 * 60 * 24))} days ago`
        );
      }
    }

    // Subject Information
    if (subjectInfo.success) {
      console.log('\nüîπ SUBJECT (Certificate Owner):');
      console.log(`Common Name: ${subjectInfo.commonName}`);
      console.log(`Organization: ${subjectInfo.organization}`);
      console.log(`Organizational Unit: ${subjectInfo.organizationalUnit}`);
      console.log(`Country: ${subjectInfo.country}`);
      console.log(`State/Province: ${subjectInfo.state}`);
      console.log(`Locality: ${subjectInfo.locality}`);
      if (subjectInfo.email) {
        console.log(`Email: ${subjectInfo.email}`);
      }
    }

    // Issuer Information
    if (issuerInfo.success) {
      console.log('\nüîπ ISSUER (Certificate Authority):');
      console.log(`CA Name: ${issuerInfo.commonName}`);
      console.log(`CA Organization: ${issuerInfo.organization}`);
      console.log(`CA Country: ${issuerInfo.country}`);
      if (issuerInfo.email) {
        console.log(`CA Email: ${issuerInfo.email}`);
      }
    }

    // Validation Results
    console.log('\nüîπ VALIDATION STATUS:');
    console.log(`Overall Valid: ${validation.valid ? '‚úÖ Yes' : '‚ùå No'}`);
    console.log(`Chain Valid: ${validation.chainValid ? '‚úÖ Yes' : '‚ùå No'}`);
    console.log(
      `Revocation Status: ${validation.revoked ? '‚ùå Revoked' : '‚úÖ Not Revoked'}`
    );
    console.log(`Self-Signed: ${validation.selfSigned ? 'Yes' : 'No'}`);

    if (!validation.valid && validation.reason) {
      console.log(`Validation Error: ${validation.reason}`);
    }

    // Key Usage
    if (keyUsage.success) {
      console.log('\nüîπ KEY USAGE:');
      const usages = [];
      if (keyUsage.digitalSignature) usages.push('Digital Signature');
      if (keyUsage.keyEncipherment) usages.push('Key Encipherment');
      if (keyUsage.dataEncipherment) usages.push('Data Encipherment');
      if (keyUsage.keyAgreement) usages.push('Key Agreement');
      if (keyUsage.certSign) usages.push('Certificate Signing');
      if (keyUsage.crlSign) usages.push('CRL Signing');

      console.log(`Allowed Uses: ${usages.join(', ')}`);
    }

    // Public Key
    if (publicKey.success) {
      console.log('\nüîπ PUBLIC KEY:');
      console.log(`Algorithm: ${publicKey.algorithm}`);
      console.log(`Key Size: ${publicKey.keySize} bits`);
      console.log(`Key Hash: ${publicKey.publicKey.substring(0, 64)}...`);
    }

    // Extensions Summary
    if (extensions.success) {
      console.log('\nüîπ EXTENSIONS:');
      console.log(`Total Extensions: ${extensions.list.length}`);

      const criticalExtensions = extensions.list.filter(ext => ext.critical);
      console.log(`Critical Extensions: ${criticalExtensions.length}`);

      if (criticalExtensions.length > 0) {
        console.log('Critical Extensions:');
        criticalExtensions.forEach(ext => {
          console.log(`  - ${ext.name || ext.oid}`);
        });
      }
    }

    console.log('\nüéâ Certificate analysis completed!');

    return {
      certificate: cert,
      subject: subjectInfo,
      issuer: issuerInfo,
      validation: validation,
      keyUsage: keyUsage,
      publicKey: publicKey,
      extensions: extensions,
      summary: {
        valid: validation.valid,
        currentlyValid: isCurrentlyValid,
        issuerName: issuerInfo.success ? issuerInfo.commonName : 'Unknown',
        subjectName: subjectInfo.success ? subjectInfo.commonName : 'Unknown',
        algorithm: cert.signatureAlgorithm,
        keySize: publicKey.success ? publicKey.keySize : 'Unknown'
      }
    };
  } catch (error) {
    console.error('‚ùå Certificate analysis failed:', error);
    throw error;
  }
}
```

### Certificate Comparison Tool

```typescript
async function compareCertificates(cert1Data: string, cert2Data: string) {
  try {
    console.log('üîç Comparing two certificates...');

    // Parse both certificates
    const [cert1Info, cert2Info] = await Promise.all([
      x509Plugin.parseCertificateAsync(cert1Data),
      x509Plugin.parseCertificateAsync(cert2Data)
    ]);

    if (!cert1Info.success || !cert2Info.success) {
      throw new Error('Failed to parse one or both certificates');
    }

    const cert1 = cert1Info.certificate!;
    const cert2 = cert2Info.certificate!;

    console.log('\nüìä CERTIFICATE COMPARISON REPORT');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    // Basic comparison
    console.log('\nüîπ BASIC INFORMATION:');
    console.log(`Certificate 1 Serial: ${cert1.serialNumber}`);
    console.log(`Certificate 2 Serial: ${cert2.serialNumber}`);
    console.log(
      `Same Serial: ${cert1.serialNumber === cert2.serialNumber ? '‚úÖ Yes' : '‚ùå No'}`
    );

    console.log(`Certificate 1 Subject: ${cert1.subject}`);
    console.log(`Certificate 2 Subject: ${cert2.subject}`);
    console.log(
      `Same Subject: ${cert1.subject === cert2.subject ? '‚úÖ Yes' : '‚ùå No'}`
    );

    console.log(`Certificate 1 Issuer: ${cert1.issuer}`);
    console.log(`Certificate 2 Issuer: ${cert2.issuer}`);
    console.log(
      `Same Issuer: ${cert1.issuer === cert2.issuer ? '‚úÖ Yes' : '‚ùå No'}`
    );

    // Validity comparison
    console.log('\nüîπ VALIDITY COMPARISON:');
    const cert1NotBefore = new Date(cert1.notBefore);
    const cert1NotAfter = new Date(cert1.notAfter);
    const cert2NotBefore = new Date(cert2.notBefore);
    const cert2NotAfter = new Date(cert2.notAfter);

    console.log(
      `Certificate 1: ${cert1NotBefore.toLocaleDateString()} - ${cert1NotAfter.toLocaleDateString()}`
    );
    console.log(
      `Certificate 2: ${cert2NotBefore.toLocaleDateString()} - ${cert2NotAfter.toLocaleDateString()}`
    );

    const cert1Duration = cert1NotAfter.getTime() - cert1NotBefore.getTime();
    const cert2Duration = cert2NotAfter.getTime() - cert2NotBefore.getTime();

    console.log(
      `Certificate 1 Duration: ${Math.ceil(cert1Duration / (1000 * 60 * 60 * 24))} days`
    );
    console.log(
      `Certificate 2 Duration: ${Math.ceil(cert2Duration / (1000 * 60 * 60 * 24))} days`
    );

    // Public key comparison
    console.log('\nüîπ PUBLIC KEY COMPARISON:');
    const [publicKey1, publicKey2] = await Promise.all([
      x509Plugin.getPublicKeyAsync(cert1Data),
      x509Plugin.getPublicKeyAsync(cert2Data)
    ]);

    if (publicKey1.success && publicKey2.success) {
      console.log(
        `Certificate 1 Algorithm: ${publicKey1.algorithm}, Size: ${publicKey1.keySize} bits`
      );
      console.log(
        `Certificate 2 Algorithm: ${publicKey2.algorithm}, Size: ${publicKey2.keySize} bits`
      );
      console.log(
        `Same Public Key: ${publicKey1.publicKey === publicKey2.publicKey ? '‚úÖ Yes' : '‚ùå No'}`
      );
    }

    // Extensions comparison
    const [ext1, ext2] = await Promise.all([
      x509Plugin.getExtensionsAsync(cert1Data),
      x509Plugin.getExtensionsAsync(cert2Data)
    ]);

    if (ext1.success && ext2.success) {
      console.log('\nüîπ EXTENSIONS COMPARISON:');
      console.log(`Certificate 1 Extensions: ${ext1.list.length}`);
      console.log(`Certificate 2 Extensions: ${ext2.list.length}`);

      const ext1Oids = ext1.list.map(e => e.oid).sort();
      const ext2Oids = ext2.list.map(e => e.oid).sort();

      const sameExtensions =
        JSON.stringify(ext1Oids) === JSON.stringify(ext2Oids);
      console.log(`Same Extensions: ${sameExtensions ? '‚úÖ Yes' : '‚ùå No'}`);

      if (!sameExtensions) {
        const uniqueToExt1 = ext1Oids.filter(oid => !ext2Oids.includes(oid));
        const uniqueToExt2 = ext2Oids.filter(oid => !ext1Oids.includes(oid));

        if (uniqueToExt1.length > 0) {
          console.log(
            'Extensions only in Certificate 1:',
            uniqueToExt1.join(', ')
          );
        }
        if (uniqueToExt2.length > 0) {
          console.log(
            'Extensions only in Certificate 2:',
            uniqueToExt2.join(', ')
          );
        }
      }
    }

    // Determine relationship
    console.log('\nüîπ RELATIONSHIP ANALYSIS:');
    if (
      cert1.serialNumber === cert2.serialNumber &&
      cert1.subject === cert2.subject &&
      cert1.issuer === cert2.issuer
    ) {
      console.log('üîÑ These appear to be the SAME certificate');
    } else if (
      cert1.subject === cert2.subject &&
      cert1.issuer === cert2.issuer
    ) {
      console.log(
        'üîÑ These appear to be RENEWED versions of the same certificate'
      );
    } else if (cert1.subject === cert2.subject) {
      console.log(
        'üîÑ These certificates have the SAME SUBJECT but different issuers'
      );
    } else if (cert1.issuer === cert2.issuer) {
      console.log(
        'üîÑ These certificates have the SAME ISSUER but different subjects'
      );
    } else {
      console.log('üîÑ These are COMPLETELY DIFFERENT certificates');
    }

    console.log('\nüéâ Certificate comparison completed!');
  } catch (error) {
    console.error('‚ùå Certificate comparison failed:', error);
    throw error;
  }
}
```

### Certificate Chain Validator

```typescript
async function validateCertificateChain(certificates: string[]) {
  try {
    console.log(
      `üîó Validating certificate chain (${certificates.length} certificates)...`
    );

    // Parse all certificates
    const certInfos = await Promise.all(
      certificates.map(cert => x509Plugin.parseCertificateAsync(cert))
    );

    // Check if all certificates parsed successfully
    if (!certInfos.every(info => info.success)) {
      throw new Error('Failed to parse one or more certificates in the chain');
    }

    console.log('\nüîó CERTIFICATE CHAIN ANALYSIS');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    // Display chain hierarchy
    console.log('\nüîπ CHAIN HIERARCHY:');
    certInfos.forEach((certInfo, index) => {
      const cert = certInfo.certificate!;
      const level =
        index === 0
          ? 'End Entity'
          : index === certInfos.length - 1
            ? 'Root CA'
            : `Intermediate CA ${index}`;

      console.log(`${index + 1}. ${level}`);
      console.log(`   Subject: ${cert.subject}`);
      console.log(`   Issuer: ${cert.issuer}`);
      console.log(`   Serial: ${cert.serialNumber}`);
      console.log(`   Valid: ${cert.notBefore} - ${cert.notAfter}`);
    });

    // Validate chain structure
    console.log('\nüîπ CHAIN VALIDATION:');
    const validationErrors = [];

    for (let i = 0; i < certInfos.length - 1; i++) {
      const currentCert = certInfos[i].certificate!;
      const nextCert = certInfos[i + 1].certificate!;

      // Check if current cert is issued by next cert
      if (currentCert.issuer === nextCert.subject) {
        console.log(
          `‚úÖ Certificate ${i + 1} correctly issued by Certificate ${i + 2}`
        );
      } else {
        const error = `‚ùå Certificate ${i + 1} issuer doesn't match Certificate ${i + 2} subject`;
        console.log(error);
        validationErrors.push(error);
      }
    }

    // Check root certificate (self-signed)
    const rootCert = certInfos[certInfos.length - 1].certificate!;
    if (rootCert.subject === rootCert.issuer) {
      console.log('‚úÖ Root certificate is self-signed');
    } else {
      const error = '‚ùå Root certificate is not self-signed';
      console.log(error);
      validationErrors.push(error);
    }

    // Validate each certificate individually
    console.log('\nüîπ INDIVIDUAL CERTIFICATE VALIDATION:');
    const individualValidations = await Promise.all(
      certificates.map(cert => x509Plugin.validateCertificateAsync(cert))
    );

    individualValidations.forEach((validation, index) => {
      const cert = certInfos[index].certificate!;
      const level =
        index === 0
          ? 'End Entity'
          : index === certInfos.length - 1
            ? 'Root CA'
            : `Intermediate CA ${index}`;

      console.log(`${level}: ${validation.valid ? '‚úÖ Valid' : '‚ùå Invalid'}`);

      if (!validation.valid) {
        console.log(`  Reason: ${validation.reason}`);
        if (validation.expired) console.log('  - Expired');
        if (validation.revoked) console.log('  - Revoked');
        if (!validation.chainValid) console.log('  - Chain invalid');
      }
    });

    // Overall chain validation
    console.log('\nüîπ OVERALL CHAIN STATUS:');
    const chainValid =
      validationErrors.length === 0 &&
      individualValidations.every(v => v.valid);

    console.log(
      `Chain Structure: ${validationErrors.length === 0 ? '‚úÖ Valid' : '‚ùå Invalid'}`
    );
    console.log(
      `All Certificates Valid: ${individualValidations.every(v => v.valid) ? '‚úÖ Yes' : '‚ùå No'}`
    );
    console.log(
      `Overall Chain Valid: ${chainValid ? '‚úÖ Valid' : '‚ùå Invalid'}`
    );

    if (validationErrors.length > 0) {
      console.log('\nStructural Errors:');
      validationErrors.forEach(error => console.log(`  ${error}`));
    }

    console.log('\nüéâ Certificate chain validation completed!');

    return {
      valid: chainValid,
      certificates: certInfos.map(info => info.certificate!),
      validations: individualValidations,
      structuralErrors: validationErrors,
      chainLength: certificates.length
    };
  } catch (error) {
    console.error('‚ùå Certificate chain validation failed:', error);
    throw error;
  }
}
```

## Callback API (Legacy)

### parseCertificate() - Callback Version

```typescript
x509Plugin.parseCertificate(
  certificateData,
  (event, response) => {
    if (response.success && response.certificate) {
      console.log('Callback: Certificate parsed');
      console.log('Subject:', response.certificate.subject);
      console.log('Issuer:', response.certificate.issuer);
    } else {
      console.error('Callback: Parse failed:', response.reason);
    }
  },
  error => {
    console.error('Callback: Parse error:', error);
  }
);
```

### validateCertificate() - Callback Version

```typescript
x509Plugin.validateCertificate(
  certificateData,
  { checkRevocation: true },
  (event, response) => {
    if (response.success) {
      console.log('Callback: Validation result:', response.valid);
    }
  },
  error => {
    console.error('Callback: Validation error:', error);
  }
);
```

## Error Handling

### Certificate Parse Errors

```typescript
try {
  const result = await x509Plugin.parseCertificateAsync(certData);
} catch (error) {
  if (error.message.includes('invalid format')) {
    console.error('‚ùå Certificate format is invalid');
  } else if (error.message.includes('not base64')) {
    console.error('‚ùå Certificate must be base64 encoded');
  } else if (error.message.includes('corrupted')) {
    console.error('‚ùå Certificate data is corrupted');
  } else {
    console.error('‚ùå Certificate parse error:', error.message);
  }
}
```

### Validation Errors

```typescript
try {
  const validation = await x509Plugin.validateCertificateAsync(certData);
} catch (error) {
  if (error.message.includes('truststore')) {
    console.error('‚ùå Truststore not found or invalid');
  } else if (error.message.includes('network')) {
    console.error('‚ùå Network error during revocation check');
  } else if (error.message.includes('timeout')) {
    console.error('‚ùå Validation timeout');
  } else {
    console.error('‚ùå Validation error:', error.message);
  }
}
```

## Best Practices

1. **Certificate Format**: Always use base64 encoded certificates
2. **Validation**: Always validate certificates before trusting
3. **Chain Validation**: Validate complete certificate chains
4. **Revocation Checking**: Enable revocation checking for critical applications
5. **Error Handling**: Handle certificate parsing and validation errors
   gracefully
6. **Performance**: Cache validation results when appropriate
7. **Security**: Never trust expired or revoked certificates
8. **Extensions**: Pay attention to critical extensions
9. **Algorithm Support**: Check signature algorithm compatibility
10. **Time Validation**: Always check certificate validity periods
